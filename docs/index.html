<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="./">
  <title data-ice="title">Manual | path.ux</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="this is awesome library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="path.ux"><meta property="twitter:description" content="this is awesome library"></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/joeedh/path.ux.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#introduction" data-ice="link">Introduction</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#context" data-ice="link">Context</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/architecture.html"><a href="manual/architecture.html#tool-contexts" data-ice="link">Tool Contexts</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/architecture.html"><a href="manual/architecture.html#history" data-ice="link">History</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html" data-ice="link">NStructJS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html#controller-how-fields-are-saved" data-ice="link">Controller How Fields Are Saved</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/nstructjs.html"><a href="manual/nstructjs.html#versioning" data-ice="link">Versioning</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html" data-ice="link">Tool System</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#context" data-ice="link">Context</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#undo" data-ice="link">Undo</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#tooldef--" data-ice="link">tooldef()</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/toolsystem.html"><a href="manual/toolsystem.html#tool-properties" data-ice="link">Tool Properties</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/controller.html"><a href="manual/controller.html" data-ice="link">Object Wrapping Example</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/libblock.html"><a href="manual/libblock.html#database-library" data-ice="link">Database Library</a></li>
<li data-ice="manualNav" class="indent-h1" data-link="manual/libblock.html"><a href="manual/libblock.html#struct-scripts" data-ice="link">Struct scripts</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/datagraph.html"><a href="manual/datagraph.html" data-ice="link">Data Graph</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/datagraph.html"><a href="manual/datagraph.html#declaration" data-ice="link">Declaration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/datagraph.html"><a href="manual/datagraph.html#cycles" data-ice="link">Cycles</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/datagraph.html"><a href="manual/datagraph.html#data-blocks" data-ice="link">Data Blocks</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/datagraph.html"><a href="manual/datagraph.html#zombie-nodes" data-ice="link">Zombie Nodes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    </ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><h1 id="introduction">Introduction</h1><p>Webgl-app-framework is a small app framework based on the Blender&apos;s architecture.
It uses path.ux, a UI framework that is also based on Blender.</p>
<h1 id="architecture">Architecture</h1><ul>
<li><a href="manual/architecture.html">Overview</a></li>
<li><a href="manual/toolprop.html">Tool Properties</a></li>
<li><a href="manual/toolsystem.html">Tool System</a></li>
<li><a href="manual/libblock.html">Database Library</a></li>
<li><a href="manual/controller.html">Controller</a></li>
<li><a href="manual/datagraph.html">Data Graph</a></li>
<li><a href="manual/nstructjs.html">STRUCT</a></li>
<li><a href="manual/FrameManager.html">FrameManager</a></li>
</ul>
</div>

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>History</h1><p>Path.ux is roughly based on <a href="http://www.blender.org">Blender&apos;s</a> architecture.</p><p><a href="./manual/manual/controller.html">Main page</a></p><p>The Blender 2.5 project refactored the internal architecture into a rough MVC pattern.  The model is the core code, the view is the UI, and the controller is the glue between them.</p><p>The controller is called &quot;RNA&quot; and it uses the concept of object paths. So if you have an object, you could look up type information (and the value of) a property with a simple path, e.g. &quot;object.subobject.some_property&quot;.  Blender uses RNA for its user interface, its python api and its animation system (you can associate object paths with animation curves).</p><p>Internally the controller has a special wrapper API for blender&apos;s c-struct-based pseudo-objects.  This works extremely well as it keeps type information that&apos;s only used by the UI out of the model codebase (e.g. the model might not care that a specific color should be clamped to 0-2 instead of 0-1).  Even better, the object model presented by the controller need not match the internal data structures.</p><p>Since the controller provides type info to the UI a lot of messy boilerplate is avoided, leading to very consise layout code:</p><pre><code><code class="source-code prettyprint">def panel(layout, context):
    row = layout.row
    row.prop(context.object, &quot;some_object_property&quot;)
    row.tool(&quot;mesh.subdivide&quot;)</code>
</code></pre></div>
        <a data-ice="link" href="manual/architecture.html#history"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>NStructJS</h1><p>NStructJS is a little library for saving/loading highly structured JS objects as binary data
(for more info, see the <a href="https://github.com/joeedh/STRUCT/wiki">official documentation</a> ).
It is not suited for unstructed data (use JSON for that).<br>NStructJS arose out of the following shortcomings of JSON:</p><ul>
<li>JSON allocates objects twice.</li>
<li>JSON is slow compared to what you can get with a structured binary format</li>
</ul><p>The idea of NStructJS is to attach little scripts to your classes that define that 
class&apos;s data and how it is saved.  For example:</p><pre><code><code class="source-code prettyprint">class SomeClass {
  constructor() {
    this.data1 = 0;
    this.data2 = [1, 2, 3];
  }

  //reader &quot;fills in&quot; fields in a newly created object with loaded data
  static fromSTRUCT(reader) {
    let ret = new SomeClass();

    reader(ret);

    return ret;
  }
}
SomeClass.STRUCT = `
my_module.SomeClass {
  data1 : int;
  data2 : array;
}
nstructjs.manager.add_class(SomeClass);
`;</code>
</code></pre><h2>Controller How Fields Are Saved</h2><p>Note that you can specify little code snippets to control how fields are saved.
For example, if you want to save an integer ID instead of a reference for an 
object property, you might do this:</p><pre><code><code class="source-code prettyprint">my_module.AnotherClass {
  someclass : int | obj.someclass !== undefined ? obj.someclass.id : -1;
}</code>
</code></pre><p>Here, everything after &apos;|&apos; until &apos;;&apos; defines how someclass is saved.  For various dumb reasons
&apos;this&apos; is bound to &apos;obj&apos;; as you can see, the basic idea is to check if this.someclass exists,
if so use this.someclass.id, else use -1.</p><h2>Versioning</h2><p>To a certain extend nstructjs will gracefully handle version changes.  The basic idea is to save a
copy of your struct scripts with each file, that way each file knows how to load itself.</p><p>For more advanced versioning, see AppState.prototype.do_versions and AppState.prototype.do_versions_post.
They&apos;re used when the automatic versioning from nstructjs isn&apos;t enough.</p></div>
        <a data-ice="link" href="manual/nstructjs.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Tool System</h1><p>Tools are what the user uses to change state in the model.  They handle undo, can take control of events if needed and in generate are foundational to path.ux and it&apos;s associated projects.  </p><p>Tools all inherit from ToolOp, which roughly looks like this (see Context section for an explanation for what the &quot;ctx&quot; parameters are):</p><pre><code><code class="source-code prettyprint">class SomeTool extends ToolOp {
  static tooldef() {return {
    uiname   : &quot;Tool&quot;,
    path     : &quot;module.tool&quot;
    inputs   : ToolOp.inherit({}), //inherit properties from base class
    outputs  : {}
  }}
  static invoke(ctx, args) {
    /*create a new tool instance.
      args is simple key:val mapping
      where val is either a string, a number
      or a boolean.*/
    return new ToolOp()
  }
  undoPre(ctx) {
    //create undo data
  }
  undo(ctx) {
    //execute undo with data made in previous call to this.undoPre
  }
  exec(ctx) {
    //execute tool
  }
  modalStart(ctx) {
    //start interactice mode
  }
  modalEnd(ctx) {
    //end interactive mode
  }
  on_[mousedown/mousemove/mouseup/keydown](ctx) {
    //interactive mode event
  }

  ToolOp.register(SomeTool);
}</code>
</code></pre><h2>Context</h2><p>The foundation of the tool system is a special Context struct that&apos;s provided by client code.  Think of it as defining &quot;arguments&quot; for tools.  Path.ux can use any context struct, but requires the following properties be defined:</p><pre><code><code class="source-code prettyprint">class Context {
  get api() {
    //return reference to a controller.ModelInterface
  }

  get appstate() {
    //return reference to main appstate global
  }

  get screen() {
    //return reference to main FrameManager.screen
  }
}</code>
</code></pre><p>In addition, path.ux has hooks to provide UI context, specifically which are is currently active.  To do this,
either override the following methods in ScreenArea.Area.prototype, or subclass Area:</p><pre><code><code class="source-code prettyprint">  //called when area should be considered &quot;active&quot;
  push_ctx_active() {
  }

  //called when area should be considered &quot;inactive&quot;
  pop_ctx_active() {
  }</code>
</code></pre><h2>Undo</h2><p>Typically tools will inherit from a base class with a general, brute-force undo (i.e. saving the 
entire application and then reloading it on undo).  Additionally to save on speed and memory subclasses 
can override undoPre and undo with their own implementation.</p><h2>tooldef()</h2><p>Tools have a special tooldef() static function that &quot;defines&quot; the tool.  It returns things like
what properties the tool has, it&apos;s name, it&apos;s path in the data path system, etc.</p><h2>Tool Properties</h2><p>Tools have input and output slots.  See toolprop.js.  There are integer properties, float properties, 
various linear algebra properties (vectors, matrices), enumerations, bitflags, and in addition client code
may provide it&apos;s own property classes.</p></div>
        <a data-ice="link" href="manual/toolsystem.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Object Wrapping Example</h1><pre><code><code class="source-code prettyprint">//our test class we want to wrap
class Thing {
  constructor(name, id, location, opacity) {
    this.name = name; //str
    this.id = id; //int
    this.location = location; //enumeration
    this.opacity = opacity; //float
  }
}

//enumeration for .location member
const LocationEnum = {
  LIVING_ROOM : 0,
  BEDROOM : 1,
  DRIVEWAY : 2
};

import {DataAPI} from &apos;controller.js&apos;;

export api = new DataAPI();

//create a structure mapping to Thing
let st = api.mapStruct(Thing);

//define properties and their types
//these all have the prototype (membername, apiname, ui_name, description)

st.string(&quot;name&quot;, &quot;name&quot;, &quot;Name&quot;, &quot;Name of thing&quot;);
st.int(&quot;id&quot;, &quot;id&quot;, &quot;ID&quot;, &quot;Unique ID of thing&quot;);
st.enum(&quot;location&quot;, &quot;location&quot;, &quot;Location&quot;, &quot;Location of thing&quot;).icons({
  LIVING_ROOM : [some icon id],
  BEDROOM : [some icon id],
  DRIVEWAY : [some icon id],
});
st.float(&quot;opacity&quot;, &quot;opacity&quot;, &quot;Opacity&quot;, &quot;Transparency of thing&quot;).range(0, 1);
</code>
</code></pre></div>
        <a data-ice="link" href="manual/controller.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Struct scripts</h1><p>Datablocks must save references to other datablocks as DataRefs; for example:</p><pre><code><code class="source-code prettyprint">SomeDataBlock.STRUCT = STRUCT.inherit(SomeDataBlock, DataBlock, &quot;SomeDataBlock&quot;) + `
  anotherBlock : DataRef | DataRef.fromBlock(obj.anotherBlock);
}
`</code>
</code></pre><p>Additionally, datablocks must implement the dataLink method to re-link DataRefs at load time.  And they must
call the .afterSTRUCT method inside fromSTRUCT (this behavior is inherited from graph.Node and may become automatic
in the future).  Here&apos;s a complete example:</p><pre><code><code class="source-code prettyprint">class SomeDataBlock extends DataBlock {
  dataLink(getblock, getblock_add_user) {
    this.anotherBlock = getblock_add_user(this.anotherBlock);
  }

  static fromSTRUCT(reader) {
    reader(ret);
    ret.afterSTRUCT();
  }
}
SomeDataBlock.STRUCT = STRUCT.inherit(SomeDataBlock, DataBlock, &quot;SomeDataBlock&quot;) + `
  anotherBlock : DataRef | DataRef.fromBlock(obj.anotherBlock);
}
`</code>
</code></pre></div>
        <a data-ice="link" href="manual/libblock.html#struct-scripts"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Data Graph</h1><p>The data graph is a generic execution graph.  It&apos;s used for (some) event handling,
scene dependency relationships, shader nodes, the render engine pass compositing system,
etc.  Each of these use the data graph in a slightly different way.</p><p>The data graph is a DAG solver with optional support for cyclic graphs.</p><h2>Declaration</h2><p>Dag nodes are declared by subclassing from graph.Node.  Each subclass should implementation
an exec method and the static nodedef method, like so:</p><pre><code><code class="source-code prettyprint">class MyNode extends Node {
  constructor() {
    super();

    this.mysetting = 0;
  }

  static nodedef() {return {
    uiname : &quot;My Node&quot;,
    name   : &quot;MyNode&quot;,     //if you want to inherit sockets from parent
    inputs : Node.inherit({ //class, wrap inputs/outputs in Node.inherit
      myinput : new FloatSocket()
    }),
    outputs : {
      myoutput : new FloatSocket()
    }
  }}

  //ctx is the argument passed to Graph.prototype.exec
  exec(ctx) {
    this.outputs.myoutput.setValue(this.inputs.myinput.getValue());

    //note that child nodes aren&apos;t executed unless you call .update() on output sockets
    //except for shader nodes, which don&apos;t use .exec methods at all
    this.outputs.myoutput.update();
  }
}
MyNode.struct = STRUCT.inherit(MyNode, Node) + ~
  mysetting : int;
}
`;
nstructjs.manager.add_class(MyNode);</code>
</code></pre><h2>Cycles</h2><p>If cycles are enable, the DAG will try to solve the graph until all inputs/outputs stop changing
in value.  There are various methods in nodeSocketType for this, the most important of which is cmpValue
and diffValue (which returns a number representing &quot;change&quot; between two instances of a socket).</p><h2>Data Blocks</h2><p>Data blocks inherit from Node.  Unlike normal nodes, they are not saved inside of Graph.nodes;
instead a special ProxyNode is create on file save, and on load the ProxyNode is swapped with the
original data block.  This is to allow saving/loading of data blocks individually, without having to
save/load the entire Graph structure (this is useful for linking different files together, e.g. file A can
load parts of file B).</p><h2>Zombie Nodes</h2><p>Zombie nodes are created by the UI for event handling; the graph automatically deletes them on file load.</p></div>
        <a data-ice="link" href="manual/datagraph.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
