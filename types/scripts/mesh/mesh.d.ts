import { LogContext, MeshDrawFlags, RecalcFlags } from './mesh_base.js';
import { SimpleMesh } from '../core/simplemesh.js';
import { SceneObjectData } from '../sceneobject/sceneobject_base.js';
import { Matrix4, util, Vector3 } from '../path.ux/pathux.js';
import { CDRef } from './customdata';
import { MeshTools } from './mesh_stdtools.js';
import { MeshFeatures, MeshTypes } from './mesh_base';
import { Edge, Element, Face, Handle, Loop, LoopList, Vertex } from "./mesh_types.js";
import { ElementList } from "./mesh_element_list.js";
import { BVH, BVHSettings } from "../util/bvh.js";
import { UVWrangler } from './unwrapping.js';
import { StructReader } from "../path.ux/scripts/path-controller/types/util/nstructjs";
import { DispLayerVert } from "./mesh_displacement";
export * from "./mesh_base";
export * from "./mesh_types";
export * from "./mesh_customdata";
export * from "./mesh_element_list.js";
export declare class EIDGen {
    static STRUCT: string;
    cur: number;
    freelist: number[];
    freemap: Map<number, number> | undefined;
    constructor();
    static fromIDGen(idgen: util.IDGen): EIDGen;
    max_cur(id?: number): void;
    copy(): EIDGen;
    reserve(eid: number): void;
    makeFreeMap(): void;
    killFreeMap(): void;
    free(eid: number): void;
    next(): number;
    loadSTRUCT(reader: StructReader<this>): void;
}
export declare class EidElemMap extends Map<number, Element> {
    get<type>(id: number): type;
}
export declare class Mesh extends SceneObjectData {
    static STRUCT: string;
    min: Vector3;
    max: Vector3;
    smemo: any | undefined;
    lastDispActive: number;
    haveNgons: boolean;
    eidMap: Map<number, Element>;
    private _recalcEidMap;
    private _bvh_freelist;
    bvhSettings: BVHSettings;
    symFlag: number;
    uvRecalcGen: number;
    _totLoopFreed: number;
    _totLoopAlloc: number;
    _totFaceFreed: number;
    _totFaceAlloc: number;
    _last_bvh_key: string;
    _last_wr_key: string;
    _last_wr_loophash: number | undefined;
    _debug_id1: number;
    features: MeshFeatures;
    materials: any[];
    usesMaterial: boolean;
    bvh: BVH | undefined;
    uvWrangler: UVWrangler | undefined;
    _ltris: Loop[] | undefined;
    _ltrimap_start: any;
    _ltrimap_end: any;
    _fancyMeshes: any;
    updatelist: any;
    lastUpdateList: any;
    updateGen: number;
    partialUpdateGen: number;
    eidgen: EIDGen;
    drawflag: MeshDrawFlags;
    recalc: RecalcFlags;
    smesh: any | undefined;
    program: any | undefined;
    elists: Map<MeshTypes, ElementList<any>>;
    _elists: Array<ElementList<any>> | undefined;
    verts: ElementList<Vertex>;
    edges: ElementList<Edge>;
    handles: ElementList<Handle>;
    loops: ElementList<Loop>;
    faces: ElementList<Face>;
    uiTriangleCount: number;
    debuglog: any[] | undefined;
    constructor(features?: MeshFeatures);
    get eidmap(): any;
    get uniforms(): void;
    get loopTris(): Loop[];
    get hasCustomNormals(): boolean;
    get elements(): Generator<any, void, unknown> | IterableIterator<Element>;
    static nodedef(): {
        name: string;
        uiname: string;
        flag: number;
        inputs: {
            data: any;
        };
        outputs: {
            data: any;
        };
    };
    static blockDefine(): {
        typeName: string;
        defaultName: string;
        uiName: string;
        flag: number;
        icon: number;
    };
    static dataDefine(): {
        name: string;
        selectMask: number;
        tools: typeof MeshTools;
    };
    makeElistAliases(): void;
    compress(): number[];
    _makeEIDGen(eidgen?: any | number): EIDGen;
    hasHandles(): number;
    addHandles(): void;
    getElemLists(): ElementList<any>[];
    updateIndices(): this;
    getElemList<type extends Element>(type: any, enableFree?: any): ElementList<type>;
    debugLogClear(): void;
    debugLogCompare(mesh2: any): void;
    _element_init(e: Element, customEid?: any): void;
    makeVertex(_co: (Vector3 & Vertex) | undefined, customEid: any, lctx: any): any;
    getEdge(v1: any, v2: any): Edge | undefined;
    ensureEdge(v1: Vertex, v2: Vertex, lctx: LogContext): Edge;
    private _makeHandle;
    _diskInsert(v: Vertex, e: Edge): void;
    _diskRemove(v: Vertex, e: Edge): void;
    makeEdge(v1: Vertex, v2: Vertex, checkExist?: boolean, customEid?: any): any;
    minMax(): this;
    _makeLoop(customEid?: number | undefined): Loop;
    _allocFace(totlist?: number, customEid?: number | undefined): Face;
    _freeFace(f: Face): void;
    _killLoop(loop: Loop): void;
    _elemRemove(elem: any): void;
    countDuplicateFaces(vs: any): number;
    copyFace(f: any, new_vmap: any): Face;
    makeQuad(v1: Vertex, v2: Vertex, v3: Vertex, v4: Vertex, lctx?: LogContext | undefined): Face;
    makeTri(v1: Vertex, v2: Vertex, v3: Vertex, lctx?: LogContext | undefined, ignoreDuplicates?: boolean): Face;
    makeFace(verts: Vertex[], customEid?: number | undefined, customLoopEids?: number[] | undefined, lctx?: LogContext | undefined, logtag?: number): Face;
    _recalcNormals_intern(cd_disp?: CDRef<DispLayerVert>): void;
    _recalcVertexNormals(cd_disp?: CDRef<DispLayerVert>): void;
    allGeometry(): Generator<Vertex | Face | Edge, void, unknown>;
    recalcNormalsCustom(cd_disp?: CDRef<DispLayerVert>): void;
    recalcNormals(cd_disp?: CDRef<DispLayerVert>): void;
    killVertex(v: Vertex, _nocheck?: boolean, lctx?: LogContext, logtag?: number): void;
    killEdge(e: Edge, lctx?: LogContext, logtag?: any): void;
    replaceLoopEdge(l: Loop, newe: Edge): this;
    killFace(f: Face, lctx?: LogContext, logtag?: number): void;
    killElem(elem: Element, lctx?: LogContext, logtag?: number): void;
    setActive(e: Element): void;
    clearHighlight(): void;
    setHighlight(e: Element): void;
    /** flushes MeshFlags.UPDATE from faces/edges to vertices*/
    flushUpdateFlags(typemask?: MeshTypes): void;
    selectFlush(selmode: MeshTypes): void;
    setOrigIndex(): void;
    /**make sure we have an original index layer*/
    ensureOrigIndexLayer(): void;
    _splitEdgeNoFace(e: Edge, t: number, lctx: LogContext): [Edge, Vertex];
    _radialRemoveSafe(e: Edge, l: Loop): boolean;
    applyMatrix(matrix: Matrix4): void;
    collapseEdge(e: Edge, v_keep?: Vertex, lctx?: LogContext, snap?: boolean, depth?: number): Vertex;
    _checkElemLoops(v_or_e: Element, msg?: string): void;
    _killLoopList(list: LoopList, unlink?: boolean): void;
    reverseListWinding(list: LoopList): void;
    reverseWinding(f: Face, lctx?: LogContext): void;
    makeHole(f: Face, vs: Vertex[], customLoopEids?: number, lctx?: LogContext): LoopList;
    /** trys to connect two verts through exactly
     *  one face, which is split.  returns loop of new split edge*/
    connectVerts(v1: any, v2: any, lctx: any): Loop;
    splitFaceAtVerts(f: any, v1: any, v2: any, lctx: any): Loop;
    splitFace(f: any, l1: any, l2: any, lctx: any, noerror?: boolean): Loop;
    __splitEdgeSimple(e: any, t?: number): any[];
    splitEdge(e: any, t: number, lctx: any): [Edge, Vertex];
    splitEdgeWhileSmoothing(e: any, t: number, smoothFac: number, lctx: any): [Edge, Vertex];
    _radialInsert(e: any, l: any): void;
    pruneWireGeometry(verts: ElementList<Vertex>, lctx: any): boolean;
    _radialRemove(e: any, l: any): void;
    joinTwoEdges(v: any, lctx: any): Edge;
    _fixFace2(f: any, lctx: any, is_linked?: boolean): any;
    _fixFace(f: any, lctx: any, f_is_linked?: boolean, relink?: boolean, warn?: boolean): any;
    dissolveVertex(v: any, lctx: any): any;
    rotateEdge(e: any, dir: number, lctx: any): Edge;
    setEID(elem: any, eid: any): this;
    _checkEdge(e: any, msg: any): void;
    _checkManifold(geom: any, msg: any): void;
    _checkFaceLoops(f: any, msg: any): void;
    _checkFace(f_or_vs: any, msg: any, noerror?: boolean): boolean;
    dissolveEdge(e: any, lctx?: any): any;
    _dissolveEdge(e: any, lctx?: any): any;
    setSelect(e: any, state: any): void;
    selectNone(): void;
    selectAll(): void;
    updateGrids(): void;
    _updateElists(): void;
    resetDispLayers(): void;
    exec(ctx: any): void;
    tessellate(): void;
    prealloc(n: any): void;
    compact(): this;
    genRender_curves(gl: any, combinedWireframe: any, view3d: any, layers?: number): SimpleMesh;
    /**
     * @param gl: gl context, may be undefined
     * @param combinedWireframe: add wireframe layer (but unset simplemesh.PrimitiveTypes.LINES in primflag)
     * @param view3d: View3D instance, optional, used when drawing edges in curve mode
     * */
    genRender(gl: any, combinedWireframe?: boolean, view3d?: any): any;
    genRender_full(gl: any, combinedWireframe: any): any;
    destroy(gl: any): void;
    getUVWrangler(check?: boolean, checkUvs?: boolean): UVWrangler;
    destroyUVWrangler(): this;
    getLastBVH(): BVH;
    getBVH(auto_update_or_args?: boolean, useGrids?: boolean, force?: boolean, wireVerts?: boolean): BVH;
    genRenderBasic(combinedWireframe?: boolean): SimpleMesh;
    stripTempLayers(saveState?: boolean): {};
    unstripTempLayers(state: any): this;
    _genRender_full(gl: any, combinedWireframe?: boolean): any;
    rescale(): void;
    flagElemUpdate(e: any): void;
    partialUpdate(gl: any): any;
    checkPartialUpdate(gl: any): void;
    drawWireframe(view3d: any, gl: any, uniforms: any, program: any, object: any): void;
    onContextLost(e: any): void;
    drawIds(view3d: any, gl: any, selectMask: any, uniforms: any, object: any): void;
    updateMirrorTag(v: any, threshold?: number): void;
    doMirrorSnap(v: any, threshold?: number): void;
    updateMirrorTags(threshold?: number): void;
    _genRenderElements(gl: any, uniforms: any, combinedWireframe?: boolean): void;
    clearUpdateFlags(typemask: any): void;
    updateHandles(): void;
    _regenEidMap(): void;
    _updateEidgen(): void;
    compactEids(): void;
    _clearGPUMeshes(gl: any): void;
    drawElements(view3d: any, gl: any, selmask: any, uniforms: any, program: any, object: any, drawTransFaces?: boolean): void;
    draw(view3d: any, gl: any, uniforms: any, program: any, object: any): void;
    swapDataBlockContents(mesh: any): this;
    clearCustomData(): void;
    regenBVH(): this;
    regenTessellation(): this;
    regenUVEditor(): this;
    regenUVWrangler(): this;
    /** also calls this.regenElementsDraw and this.regenUVDraw */
    regenRender(): this;
    regenElementsDraw(): this;
    regenAll(): this;
    regenPartial(): this;
    _getArrays(): any[];
    updateBoundaryFlags(): void;
    copyElemData(dst: any, src: any, ignoreNoInterp?: boolean): void;
    /** clear mesh */
    clear(clearCustomData?: boolean): this;
    copy(addLibUsers?: boolean, clearCustomData?: boolean): this;
    _on_cdlayer_add(layer: any, set: any): void;
    _on_cdlayer_rem(layer: any, set: any): void;
    getFace(verts: Iterable<Vertex>): Face;
    fixDuplicateFaces(report?: boolean, lctx?: LogContext): void;
    fixLoops(lctx?: LogContext): void;
    fixMesh(report?: boolean, noWire?: boolean): void;
    killColinearTris(report?: boolean): void;
    validateMesh(msg_out?: [string | undefined]): boolean;
    loadSTRUCT(reader: StructReader<this>): void;
    getBoundingBox(useGrids?: boolean): any;
    copyAddUsers(): this;
}
