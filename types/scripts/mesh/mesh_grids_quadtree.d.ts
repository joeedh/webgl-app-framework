export namespace OldQuadTreeFields {
    let QFLAG: number;
    let QCHILD1: number;
    let QCHILD2: number;
    let QCHILD3: number;
    let QCHILD4: number;
    let QMINU: number;
    let QMINV: number;
    let QMAXU: number;
    let QMAXV: number;
    let QCENTU: number;
    let QCENTV: number;
    let QDEPTH: number;
    let QLEFT: number;
    let QRIGHT: number;
    let QUP: number;
    let QDOWN: number;
    let QPOINT1: number;
    let QPOINT2: number;
    let QPOINT3: number;
    let QPOINT4: number;
    let QID: number;
    let QPARENT: number;
    let QSUBTREE_DEPTH: number;
    let QQUADIDX: number;
    let QPOLYSTART: number;
    let QPOLYEND: number;
    let QTOT: number;
}
export namespace QuadTreeFields {
    let QFLAG_1: number;
    export { QFLAG_1 as QFLAG };
    let QCHILD1_1: number;
    export { QCHILD1_1 as QCHILD1 };
    let QCHILD2_1: number;
    export { QCHILD2_1 as QCHILD2 };
    let QCHILD3_1: number;
    export { QCHILD3_1 as QCHILD3 };
    let QCHILD4_1: number;
    export { QCHILD4_1 as QCHILD4 };
    let QMINU_1: number;
    export { QMINU_1 as QMINU };
    let QMINV_1: number;
    export { QMINV_1 as QMINV };
    let QMAXU_1: number;
    export { QMAXU_1 as QMAXU };
    let QMAXV_1: number;
    export { QMAXV_1 as QMAXV };
    let QCENTU_1: number;
    export { QCENTU_1 as QCENTU };
    let QCENTV_1: number;
    export { QCENTV_1 as QCENTV };
    let QDEPTH_1: number;
    export { QDEPTH_1 as QDEPTH };
    let QLEFT_1: number;
    export { QLEFT_1 as QLEFT };
    let QRIGHT_1: number;
    export { QRIGHT_1 as QRIGHT };
    let QUP_1: number;
    export { QUP_1 as QUP };
    let QDOWN_1: number;
    export { QDOWN_1 as QDOWN };
    let QPOINT1_1: number;
    export { QPOINT1_1 as QPOINT1 };
    let QPOINT2_1: number;
    export { QPOINT2_1 as QPOINT2 };
    let QPOINT3_1: number;
    export { QPOINT3_1 as QPOINT3 };
    let QPOINT4_1: number;
    export { QPOINT4_1 as QPOINT4 };
    export let QPOINT5: number;
    let QID_1: number;
    export { QID_1 as QID };
    let QPARENT_1: number;
    export { QPARENT_1 as QPARENT };
    let QSUBTREE_DEPTH_1: number;
    export { QSUBTREE_DEPTH_1 as QSUBTREE_DEPTH };
    let QQUADIDX_1: number;
    export { QQUADIDX_1 as QQUADIDX };
    let QPOLYSTART_1: number;
    export { QPOLYSTART_1 as QPOLYSTART };
    let QPOLYEND_1: number;
    export { QPOLYEND_1 as QPOLYEND };
    export let QNX: number;
    export let QNY: number;
    export let QNZ: number;
    export let QTX: number;
    export let QTY: number;
    export let QTZ: number;
    export let QBX: number;
    export let QBY: number;
    export let QBZ: number;
    export let QCENTX: number;
    export let QCENTY: number;
    export let QCENTZ: number;
    let QTOT_1: number;
    export { QTOT_1 as QTOT };
}
export class CompressedQuadNode {
    static fromNodes(ns: any): CompressedQuadNode[];
}
export namespace CompressedQuadNode {
    let fields: {};
    let STRUCT: string;
}
export namespace QuadTreeFlags {
    let SELECT: number;
    let LEAF: number;
    let DEAD: number;
    let TEMP: number;
}
export class QuadTreeGrid extends GridBase {
    static define(): {
        elemTypeMask: MeshTypes;
        typeName: string;
        settingsClass: typeof GridSettings;
        uiTypeName: string;
        defaultName: string;
        valueSize: any;
        flag: number;
    };
    leafPoints: any[];
    leafNodes: any[];
    depthLimit: number;
    depthLimitEnabled: boolean;
    normalQuad: Vector3[];
    loopEid: number;
    pmap: {};
    nodes: any[];
    freelist: any[];
    polys: any[];
    nodeFieldSize: number;
    subdtemps: util.cachering;
    _saveNodes(): CompressedQuadNode[];
    copyTo(b: any, copy_eids?: boolean): void;
    getNormalQuad(loop: any): any;
    getQuad(loop: any): any;
    smoothPoint(v: any, fac?: number): void;
    stitchBoundaries(): void;
    _hashPoint(u: any, v: any): any;
    _getPoint(u: any, v: any, loopEid: any, mesh: any, isNewOut: any): any;
    _getUV(ni: any, pidx: any): any;
    _rebuildHash(): void;
    _freeNode(ni: any): void;
    _newNode(): any;
    _ensureNodePoint(ni: any, pidx: any, loopEid: any, mesh: any, isNewOut: any): any;
    init(dimen: any, mesh: any, loop: any): this;
    topo: {
        maxdepth: number;
        vmap: {
            edges: any[];
            nodes: any[];
            index: number;
            uv: number[];
            p: any;
        }[];
        emap: Map<any, any>;
        uvmap: {};
        dimen: number;
        uvkey: (u: any, v: any) => any;
    };
    recalcFlag: number;
    printNodes(): string;
    flagTopoRecalc(): void;
    flagNeighborRecalc(): void;
    getTopo(): {
        maxdepth: number;
        vmap: {
            edges: any[];
            nodes: any[];
            index: number;
            uv: number[];
            p: any;
        }[];
        emap: Map<any, any>;
        uvmap: {};
        dimen: number;
        uvkey: (u: any, v: any) => any;
    };
    updateMirrorFlag(mesh: any, p: any, isboundary?: boolean): void;
    compactNodes(): void;
    evaluate(u: any, v: any, startNi?: number, depthLimit?: any): any;
    findNode(u: any, v: any, startNi?: number, depthLimit?: any): number;
    buildTangentMatrix(ni: any, u1: any, v1: any, matOut: any): void;
    buildTangentMatrix1(ni: any, u1: any, v1: any, matOut: any): void;
    invertTangentMatrix(mat: any): void;
    tangentToGlobalSS(inverse?: boolean): void;
    globalToTangentSS(): void;
    subdivideAll(mesh: any, loop: any, cd_grid: any): void;
    subdivideAll_intern(mesh: any, loop: any, cd_grid: any): void;
    tangentToGlobal(level?: number, inverse?: boolean): void;
    globalToTangent(level?: number): void;
    _changeMresSettings(depthLimit: any, enabled: any): void;
    mresUp(): void;
    mresDown(): void;
    checkMultiRes(mesh: any, loop: any, cd_grid: any): void;
    update(mesh: any, loop: any, cd_grid: any, _ignore_mres?: boolean): void;
    rebuildNodePolys(): {
        vmap: {
            edges: any[];
            nodes: any[];
            index: number;
            uv: number[];
            p: any;
        }[];
        emap: Map<any, any>;
        dimen: number;
        uvmap: {};
    };
    pruneDeadPoints(): void;
    collapse(ni: any): void;
    subdivide(ni: any, loopEid: any, mesh: any): void;
    _ensure(mesh: any, loop: any, cd_grid: any): void;
    _updateNormal(ni: any): void;
    checkVertNormals(mesh: any, loop: any, cd_grid: any): boolean;
    checkNodeNormals(): void;
    getLeafPoints(): any[] | Set<any>;
    getLeafNodes(): any[];
    updateNormalQuad(loop: any): void;
    uvColorTest(mesh: any, loop: any, cd_grid: any): void;
    idmul: number;
    _loadCompressedNodes(ns1?: any[]): void;
    _testNodeCompression(): void;
}
export namespace QuadTreeGrid {
    let STRUCT_1: string;
    export { STRUCT_1 as STRUCT };
}
import { GridBase } from "./mesh_grids.js";
import { Vector3 } from "../path.ux/scripts/pathux.js";
import * as util from "../util/util.js";
import { MeshTypes } from "./mesh_base.js";
import { GridSettings } from "./mesh_grids.js";
